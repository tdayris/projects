import sys
import pandas
import os.path

from snakemake.utils import min_version, makedirs
from pathlib import Path
from typing import Any, Dict

if sys.version_info < (3, 8):
    raise SystemError("Please use Python 3.8 or later")

min_version('5.16.0')
git = "https://raw.githubusercontent.com/tdayris/snakemake-wrappers/Unofficial"
singularity: "docker://continuumio/miniconda3:5.0.1"

design_path = Path("design_calling.csv")
if not design_path.exists():
    raise FileNotFoundError(f"Could not find {str(design_path)}")

design = pandas.read_csv(
    design_path,
    sep="\t",
    header=0,
    index_col=0,
    dtype=str
)

design_dict = design.to_dict()
FASTA = "resources/Mus_musculus.GRCm38.dna.toplevel.fa"


wildcard_constraints:
    sample = "|".join(design.index.tolist()),
    sample1 = "|".join(["S2", "S3", "S10", "S12", "S14", "S15"]),
    sample2 = "|".join(["S3", "S11", "S13"]),
    status = "only|shared",
    main = "|".join(design.index.tolist()),
    comparisons = "|".join([
        "S2_vs_S3",
        "S2_vs_S11",
        "S2_vs_S13",
        "S3_vs_S11",
        "S3_vs_S13",
        "S10_vs_S11",
        "S10_vs_S13",
        "S12_vs_S11",
        "S12_vs_S13",
        "S14_vs_S11",
        "S14_vs_S13",
        "S15_vs_S11",
        "S15_vs_S13",
    ])


rule all:
    input:
        calls=expand("snpeff/calls/{sample}.vcf.gz", sample=design.index),
        multiqc="qc/multiqc.html",
        intersections = expand(
            "bcftools/intersect/{comparisons}/{main}_{status}.vcf.gz",
            main=["S2", "S3", "S11", "S13", "S10", "S14", "S15", "S12"],
            status=["only", "shared"],
            comparisons = [
                "S2_vs_S3",
                "S2_vs_S11",
                "S2_vs_S13",
                "S3_vs_S11",
                "S3_vs_S13",
                "S10_vs_S11",
                "S10_vs_S13",
                "S12_vs_S11",
                "S12_vs_S13",
                "S14_vs_S11",
                "S14_vs_S13",
                "S15_vs_S11",
                "S15_vs_S13",
            ]
        )
    message:
        "Finishing pipeline "


rule haplotype_caller:
    input:
        bam = lambda wildcards: design_dict["Bam_File"][wildcards.sample],
        ref = FASTA,
        # dbsnp = ""
    output:
        gvcf = temp("gatk/haplotype_caller/{sample}.g.vcf")
    message:
        "Calling variants in {wildcards.sample} with haplotype caller"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 10240, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    params:
        extra = (
            lambda wildcards: "--create-output-variant-index"
        ),
        java_opts = (
            lambda wildcards: f"--java-options '-Xmx3G'"
        )
    log:
        "logs/haplotype_caller/{sample}.log"
    wrapper:
        f"{git}/bio/gatk/haplotypecaller"


rule mutect2:
    input:
        fasta = FASTA,
        map = lambda wildcards: design_dict["Bam_File"][wildcards.sample]
    output:
        vcf = temp("gatk/mutect2/{sample}.vcf")
    message:
        "Calling variants in {wildcards.sample} with Mutect2"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 10240, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    params:
        extra = "--create-output-variant-index -Xmx3G"
    log:
        "logs/mutect2/{sample}.log"
    wrapper:
        f"{git}/bio/gatk/mutect"


rule bcftools_call:
    input:
        ref = FASTA,
        samples = lambda wildcards: design_dict["Bam_File"][wildcards.sample],
        indexes = lambda wildcards: design_dict["Bam_Index"][wildcards.sample]
    output:
        temp("bcftools/call/{sample}.bcf")
    message:
        "Calling variants on {wildcards.sample} with BCFTools"
    threads:
        2
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 8192, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    params:
        mpileup = "--adjust-MQ 50 --min-MQ 10 --min-BQ 15",
        call = ""
    log:
        "logs/bcftools/call/{sample}.log"
    wrapper:
        f"{git}/bio/bcftools/call"


rule bcftools_convert:
    input:
        "bcftools/call/{sample}.bcf"
    output:
        "bcftools/call/{sample}.vcf"
    message:
        "Converting BCF to VCF for further inspections on {wildcards.sample}"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 4096, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    params:
        "--output-type v"
    log:
        "logs/bcftools/view/{sample}.log"
    wrapper:
        f"{git}/bio/bcftools/view"


rule strelka:
    input:
        bam = lambda wildcards: design_dict["Bam_File"][wildcards.sample]
    output:
        directory("strelka/{sample}")
    message:
        "Calling large indels with Strelka on {wildcards.sample}"
    threads:
        8
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 10240, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    params:
        ref = FASTA,
        config_extra = "",
        run_extra = ""
    log:
        "logs/strelka/{sample}.log"
    wrapper:
        f"{git}/bio/strelka/germline"


rule merge:
    input:
        haplotype_caller = "gatk/haplotype_caller/{sample}.g.vcf",
        mutect2 = "gatk/mutect2/{sample}.vcf",
        bcftools = "bcftools/call/{sample}.vcf"
    output:
        report(
            "calling/{sample}.vcf",
            caption="../reports/vcf.rst",
            category="VCF"
        )
    message:
        "Merging call results for {wildcards.sample}"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 10240, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    params:
        "--merge all --output-type v"
    log:
        "logs/bcftools/merge/{sample}.log"
    wrapper:
        f"{git}/bio/bcftools/merge"


rule compress_bcftools_call:
    input:
        "bcftools/call/{sample}.vcf"
    output:
        vcf = "bcftools/compress/{sample}.vcf.gz",
        tbi = "bcftools/compress/{sample}.vcf.gz.tbi"
    message:
        "Compressing {wildcards.sample}'s BCFTools result"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 1024, 20480)
        ),
        time_min = (
            lambda wildcards, attempt: attempt * 115
        )
    conda:
        "../../envs/biotools.yaml"
    params:
        compress = "-c",
        index = "-p vcf"
    log:
        compress = "logs/bcftool/compress/{sample}.log",
        index = "logs/bcftool/index/{sample}.log"
    shell:
        "bgzip {params.compress} {input} > {output.vcf} 2> {log.compress}"
        " && "
        "tabix {params.index} {output.vcf} > {log.index} 2>&1"


rule snpeff:
    input:
        "bcftools/call/{sample}.vcf"
    output:
        calls="snpeff/calls/{sample}.vcf.gz",
        stats="snpeff/report/{sample}.html",
        csvstats="snpeff/stats/{sample}.csv"
    message:
        "Annotating {wildcards.sample} with snpeff"
    threads:
        2
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 1024, 10240)
        ),
        time_min = (
            lambda wildcards, attempt: min(attempt * 20, 200)
        )
    params:
        reference = "GRCm38.86",
        extra = "-Xmx4g"
    log:
        "logs/snpeff/{sample}.log"
    wrapper:
        f"{git}/bio/snpeff"


rule multiqc:
    input:
        expand("snpeff/stats/{sample}.csv", sample=design.index),
        expand("snpeff/report/{sample}.html", sample=design.index)
    output:
        "qc/multiqc.html"
    message:
        "Compiling qc metrics"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 1024, 10240)
        ),
        time_min = (
            lambda wildcards, attempt: min(attempt * 20, 200)
        )
    log:
        "logs/multiqc.log"
    wrapper:
        f"{git}/bio/multiqc"


rule tabix_snpeff:
    input:
        "snpeff/calls/{sample}.vcf.gz"
    output:
        "snpeff/calls/{sample}.vcf.gz.tbi"
    message:
        "Indexing snpeff result for {wildcards.sample}"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 1024, 10240)
        ),
        time_min = (
            lambda wildcards, attempt: min(attempt * 20, 200)
        )
    params:
        '-p vcf'
    log:
        "logs/tabix/snpeff_{sample}.log"
    wrapper:
        f"{git}/bio/tabix"


rule bcftools_intersect:
    input:
        left = "snpeff/calls/{sample1}.vcf.gz",
        right = "snpeff/calls/{sample2}.vcf.gz",
        left_index = "snpeff/calls/{sample1}.vcf.gz.tbi",
        right_index = "snpeff/calls/{sample2}.vcf.gz.tbi"
    output:
        expand(
            "bcftools/intersect/{sample1}_vs_{sample2}/{isec}.vcf.gz",
            isec=["0000", "0001", "0002", "0003"],
            allow_missing=True
        )
    message:
        "Comparing {wildcards.sample1} with {wildcards.sample2}"
    threads:
        3
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 1024, 10240)
        ),
        time_min = (
            lambda wildcards, attempt: min(attempt * 20, 200)
        )
    conda:
        "../../envs/biotools.yaml"
    params:
        isec = (
            "--collapse none "  # Do collapse only if REF AND ALT are equals
            "--exclude '(INFO/DP < 10)' "  # FIlter out low coverage
            "--output-type z "  # Output should be in vcf.gz
            "--threads 1 "  # Add one additional thread for compression
        )
    log:
        isec = "logs/bcftools/intersect/{sample1}_vs_{sample2}.log"
    shell:
        "bcftools isec "
        " {params.isec} "
        " --prefix {output} "
        " {input.left} "
        " {input.right} "
        " > {log.isec} "
        " 2>&1 "


rule bcftools_isec_rename:
    input:
        s1_only = "bcftools/intersect/{sample1}_vs_{sample2}/0000.vcf.gz",
        s2_only = "bcftools/intersect/{sample1}_vs_{sample2}/0001.vcf.gz",
        s1 = "bcftools/intersect/{sample1}_vs_{sample2}/0002.vcf.gz",
        s2 = "bcftools/intersect/{sample1}_vs_{sample2}/0003.vcf.gz"
    output:
        s1_only = "bcftools/intersect/{sample1}_vs_{sample2}/{sample1}_only.vcf.gz",
        s2_only = "bcftools/intersect/{sample1}_vs_{sample2}/{sample2}_only.vcf.gz",
        s1 = "bcftools/intersect/{sample1}_vs_{sample2}/{sample1}_shared.vcf.gz",
        s2 = "bcftools/intersect/{sample1}_vs_{sample2}/{sample2}_shared.vcf.gz"
    message:
        "Renaming intersections for {wildcards.sample1} vs {wildcards.sample2}"
    threads:
        1
    resources:
        mem_mb = (
            lambda wildcards, attempt: min(attempt * 1024, 10240)
        ),
        time_min = (
            lambda wildcards, attempt: min(attempt * 20, 200)
        )
    params:
        "--verbose"
    conda:
        "../../envs/bash.yaml"
    log:
        s1_only = "logs/bcftools/isec_rename/{sample1}_{sample2}_s1_only.log",
        s2_only = "logs/bcftools/isec_rename/{sample1}_{sample2}_s2_only.log",
        s1 = "logs/bcftools/isec_rename/{sample1}_{sample2}_s1_shared.log",
        s2 = "logs/bcftools/isec_rename/{sample1}_{sample2}_s2_shared.log"
    shell:
        "mv {params} {input.s1_only} {output.s1_only} > {log.s1_only} 2>&1 && "
        "mv {params} {input.s2_only} {output.s2_only} > {log.s1_only} 2>&1 && "
        "mv {params} {input.s1} {output.s1} > {log.s1} 2>&1 && "
        "mv {params} {input.s2} {output.s2} > {log.s2} 2>&1 "
